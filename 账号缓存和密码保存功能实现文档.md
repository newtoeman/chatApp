# 账号缓存和密码保存功能实现文档

## 功能概述
实现了仿微信APP的登录界面，包含以下核心功能：
1. 手机号缓存功能：支持缓存多个手机号，通过下拉框选择
2. 密码保存功能：可为每个手机号单独保存密码
3. 记住密码功能：通过复选框控制是否保存当前账号密码

## 核心组件

### 1. PreferencesManager类（F:\androidProject\ChatApp\app\src\main\java\com\example\chatapp\utils\PreferencesManager.kt）

#### 主要功能方法：
- `saveCachedPhoneNumbers(phoneNumbers: Set<String>)` - 保存手机号列表
- `getCachedPhoneNumbers(): Set<String>` - 获取所有缓存的手机号
- `addCachedPhoneNumber(phoneNumber: String)` - 添加单个手机号到缓存
- `savePasswordForPhone(phone: String, password: String)` - 为特定手机号保存密码
- `getPasswordForPhone(phone: String): String` - 获取特定手机号的密码
- `hasPasswordForPhone(phone: String): Boolean` - 检查特定手机号是否有缓存密码
- `removePasswordForPhone(phone: String)` - 删除特定手机号的密码缓存
- `clearAllCache()` - 清除所有缓存数据

#### 设计特点：
- 采用单例模式，确保全局唯一实例
- 每个手机号的密码独立存储，避免不同账号间密码混淆
- 使用"password_$phone"格式的键名存储特定手机号的密码

### 2. LoginScreen界面（F:\androidProject\ChatApp\app\src\main\java\com\example\chatapp\ui\login\LoginScreen.kt）

#### 界面组件：
- **手机号下拉选择框**：显示所有缓存的手机号，支持手动输入和下拉选择
- **密码输入框**：输入账号密码
- **记住密码复选框**：控制是否保存当前账号密码

#### 核心逻辑：

1. **初始化状态**：
```kotlin
var phone by remember { 
    val initialPhone = prefsManager.getCachedPhoneNumbers().firstOrNull() ?: ""
    mutableStateOf(initialPhone) 
}
var password by remember { 
    val initialPhone = prefsManager.getCachedPhoneNumbers().firstOrNull() ?: ""
    val initialPassword = if (initialPhone.isNotEmpty() && prefsManager.hasPasswordForPhone(initialPhone)) {
        prefsManager.getPasswordForPhone(initialPhone)
    } else {
        ""
    }
    mutableStateOf(initialPassword) 
}
var isRememberPassword by remember { 
    val initialPhone = prefsManager.getCachedPhoneNumbers().firstOrNull() ?: ""
    mutableStateOf(initialPhone.isNotEmpty() && prefsManager.hasPasswordForPhone(initialPhone)) 
}
```

2. **手机号选择处理**：
```kotlin
ListItem(
    headlineContent = { Text(cachedPhone) },
    modifier = Modifier.clickable {
        selectedPhone = cachedPhone
        phone = cachedPhone
        
        // 检查该手机号是否有缓存的密码
        if (prefsManager.hasPasswordForPhone(cachedPhone)) {
            password = prefsManager.getPasswordForPhone(cachedPhone)
            isRememberPassword = true
        } else {
            password = ""
            isRememberPassword = false
        }
        
        showDropdown = false
    }
)
```

3. **手机号手动输入处理**：
```kotlin
OutlinedTextField(
    value = selectedPhone,
    onValueChange = { 
        selectedPhone = it
        phone = it
        // 当手动输入手机号时，检查该手机号是否有缓存的密码
        if (prefsManager.hasPasswordForPhone(it)) {
            password = prefsManager.getPasswordForPhone(it)
            isRememberPassword = true
        } else {
            password = ""
            isRememberPassword = false
        }
    },
    // ...
)
```

4. **登录/注册成功处理**：
```kotlin
is LoginState.LoginSuccess -> {
    Toast.makeText(context, "登录成功", Toast.LENGTH_SHORT).show()
    // 缓存手机号
    prefsManager.addCachedPhoneNumber(phone)
    
    // 根据是否记住密码保存凭据
    if (isRememberPassword) {
        prefsManager.savePasswordForPhone(phone, password) // 保存特定手机号的密码
    } else {
        prefsManager.removePasswordForPhone(phone) // 清除特定手机号的密码
    }
}
```

### 3. 数据流向

#### 保存流程：
1. 用户输入手机号和密码
2. 用户勾选"记住密码"复选框
3. 登录/注册成功后，调用`prefsManager.savePasswordForPhone(phone, password)`
4. 系统将密码按"password_$phone"格式保存到SharedPreferences

#### 读取流程：
1. 应用启动时，获取缓存的所有手机号
2. 选择默认手机号或第一个缓存的手机号
3. 检查该手机号是否有缓存密码：`prefsManager.hasPasswordForPhone(phone)`
4. 如果有缓存密码，自动填入密码框：`prefsManager.getPasswordForPhone(phone)`

#### 状态同步：
- 点击下拉列表中的手机号 → 自动填充密码 → 更新rememberPassword状态
- 手动输入手机号 → 检查并填充密码 → 更新rememberPassword状态
- 勾选/取消勾选"记住密码" → 控制是否保存当前密码

## 特色功能

### 1. 智能密码填充
- 选择不同手机号时，自动识别并填充对应的密码
- 如果当前手机号没有保存密码，清空密码框并取消记住密码选项

### 2. 独立缓存管理
- 每个手机号的密码独立存储和管理
- 避免了多个账号间密码互相影响的问题

### 3. 用户体验优化
- 初始加载时自动显示最近使用的账号
- 记住密码选项状态随手机号选择而自动调整
- 下拉列表清晰显示所有已缓存的手机号

## 安全考虑

### 存储安全：
- 密码以明文形式存储在本地SharedPreferences中（适用于演示，实际应用中建议加密）
- 不同手机号的密码独立存储，避免混淆

### 隐私保护：
- 用户可随时取消"记住密码"选项，系统将立即删除相应密码缓存
- 提供清除所有缓存的功能

## 注意事项

1. 当前实现中密码以明文形式存储，生产环境应考虑加密存储
2. SharedPreferences适用于轻量级数据存储，大量数据应考虑使用数据库
3. 应用卸载后，所有缓存数据将被清除
4. 不同用户之间的数据通过手机号隔离，确保数据独立性